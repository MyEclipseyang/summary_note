### JDBC中的事务

#### 脏读

如果设置事务中允许读取未提交的数据，。例如，A事务修改了一条数据，但是未提交修改，此时A事务对数据的修改对其他事务是可见的，B事务中能够读取A事务未提交的修改。一旦A事务回滚，B事务中读取的就是不正确的数据。

一个事务修改的数据能被另一个事务感知到，也就是说，A没提交修改的数据B却能读取

<!-- more -->

#### 不可重复读

（1）A事务中读取一行数据。

（2）B事务中修改了该行数据。

（3）A事务中再次读取该行数据将得到不同的结果。

虽然一个事务修改的数据不能被另一个事务感知到，但是一条记录能同时被两个事务操作，A事务读取了一条记录，B事务同时却能修改

#### 幻读

（1）A事务中通过WHERE条件读取若干行。

（2）B事务中插入了符合条件的若干条数据。

（3）A事务中通过相同的条件再次读取数据时将会读取到B事务中插入的数据。

#### 事务隔离规范

> MySQL默认隔离级别为 TRANSACTION_REPEATABLE_READ = 4

JDBC遵循SQL:2003规范，定义了4种事务隔离级别，另外增加了一种TRANSACTION_NONE，表示不支持事务。这几种事务隔离级别如下：

> TRANSACTION_NONE：表示驱动不支持事务，这意味着它是不兼容JDBC规范的驱动程序。
> TRANSACTION_READ_UNCOMMITTED：允许事务读取未提交更改的数据，这意味着可能会出现脏读、不可重复读、幻读等现象。TRANSACTION_READ_COMMITTED：表示在事务中进行的任何数据更改，在提交之前对其他事务是不可见的。这样可以防止脏读，但是不能解决不可重复读和幻读的问题。
> TRANSACTION_REPEATABLE_READ：该事务隔离级别能够解决脏读和不可重复读问题，但是不能解决幻读问题。TRANSACTION_SERIALIZABLE：该事务隔离级别下，所有事务串行执行，能够有效解决脏读、不可重复读和幻读问题，但是并发效率较低。