### 使用Java调用native方法

#### 1.编写普通Java类

```java
/**
 * @author zyy
 * @title: HelloNative
 * @description: HelloNative
 * @date 2020/9/3 9:21
 */
public class HelloNative {
    //本地方法
    public native void hello();
    
    static {
        //加载实现hello方法的dll库文件
        System.loadLibrary("Dll1");
    }

    public static void main(String[] args) {
        new HelloNative().hello();
    }
}
```

#### 2.编译Java文件

```powershell
javac HelloNative.java
```

#### 3.生成对应头文件

```
javah -jni HelloNative.class
```

```c
//会生成HelloNative.h

/* DO NOT EDIT THIS FILE - it is machine generated */
#include "jni.h"
/* Header for class HelloNative */

#ifndef _Included_HelloNative
#define _Included_HelloNative
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     HelloNative
 * Method:    hello
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_HelloNative_hello
  (JNIEnv *, jobject);

#ifdef __cplusplus
}
#endif
#endif

```

#### 4.用vs新建C++动态链接库项目

> 我使用的是VS2019,需要把需要的头文件引入项目，引入头文件时需要右键打开项目所在文件位置粘贴过去
>
> 头文件jni jni_md 和jawt_md在jdk所在目录的include文件夹内
>
> 我电脑上的路径是：C:\Program Files\Java\jdk1.8.0_202\include

![](..\md_img\project_struct.png)

#### 5.在dllmain.app内写实现方法

```c
// dllmain.cpp : 定义 DLL 应用程序的入口点。
#include "pch.h"
#include "jni.h"
#include "HelloNative.h"
#include <stdio.h>

JNIEXPORT void JNICALL Java_HelloNative_hello(JNIEnv* env, jobject obj) {
	printf("hello native!");
}
```

#### 6.右键生成

> 如果使用的jdk为64位的，需要在 生成->配置管理器->平台 设置为x64位

![](..\md_img\final.png)

> 将生成的dll文件放在jvm能扫描到的地方Java HelloNative就行了

![](..\md_img\all_file.png)

![](..\md_img\result.png)

#### 7.查看jvm能扫描到的library路径

```java
	String property = System.getProperty("java.library.path");
    String[] split = property.split(";");
    for (String item : split) {
        System.out.println(item);
    }
```

> 编辑`crontab`文件，一般在`/etc`下